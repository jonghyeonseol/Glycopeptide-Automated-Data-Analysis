[
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "seaborn",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "seaborn",
        "description": "seaborn",
        "detail": "seaborn",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "stats",
        "importPath": "scipy",
        "description": "scipy",
        "isExtraImport": true,
        "detail": "scipy",
        "documentation": {}
    },
    {
        "label": "stats",
        "importPath": "scipy",
        "description": "scipy",
        "isExtraImport": true,
        "detail": "scipy",
        "documentation": {}
    },
    {
        "label": "stats",
        "importPath": "scipy",
        "description": "scipy",
        "isExtraImport": true,
        "detail": "scipy",
        "documentation": {}
    },
    {
        "label": "pearsonr",
        "importPath": "scipy.stats",
        "description": "scipy.stats",
        "isExtraImport": true,
        "detail": "scipy.stats",
        "documentation": {}
    },
    {
        "label": "Rectangle",
        "importPath": "matplotlib.patches",
        "description": "matplotlib.patches",
        "isExtraImport": true,
        "detail": "matplotlib.patches",
        "documentation": {}
    },
    {
        "label": "Rectangle",
        "importPath": "matplotlib.patches",
        "description": "matplotlib.patches",
        "isExtraImport": true,
        "detail": "matplotlib.patches",
        "documentation": {}
    },
    {
        "label": "Ellipse",
        "importPath": "matplotlib.patches",
        "description": "matplotlib.patches",
        "isExtraImport": true,
        "detail": "matplotlib.patches",
        "documentation": {}
    },
    {
        "label": "LinearSegmentedColormap",
        "importPath": "matplotlib.colors",
        "description": "matplotlib.colors",
        "isExtraImport": true,
        "detail": "matplotlib.colors",
        "documentation": {}
    },
    {
        "label": "venn3",
        "importPath": "matplotlib_venn",
        "description": "matplotlib_venn",
        "isExtraImport": true,
        "detail": "matplotlib_venn",
        "documentation": {}
    },
    {
        "label": "venn3_circles",
        "importPath": "matplotlib_venn",
        "description": "matplotlib_venn",
        "isExtraImport": true,
        "detail": "matplotlib_venn",
        "documentation": {}
    },
    {
        "label": "GridSpec",
        "importPath": "matplotlib.gridspec",
        "description": "matplotlib.gridspec",
        "isExtraImport": true,
        "detail": "matplotlib.gridspec",
        "documentation": {}
    },
    {
        "label": "rpy2.robjects",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "rpy2.robjects",
        "description": "rpy2.robjects",
        "detail": "rpy2.robjects",
        "documentation": {}
    },
    {
        "label": "pandas2ri",
        "importPath": "rpy2.robjects",
        "description": "rpy2.robjects",
        "isExtraImport": true,
        "detail": "rpy2.robjects",
        "documentation": {}
    },
    {
        "label": "importr",
        "importPath": "rpy2.robjects.packages",
        "description": "rpy2.robjects.packages",
        "isExtraImport": true,
        "detail": "rpy2.robjects.packages",
        "documentation": {}
    },
    {
        "label": "localconverter",
        "importPath": "rpy2.robjects.conversion",
        "description": "rpy2.robjects.conversion",
        "isExtraImport": true,
        "detail": "rpy2.robjects.conversion",
        "documentation": {}
    },
    {
        "label": "adjust_text",
        "importPath": "adjustText",
        "description": "adjustText",
        "isExtraImport": true,
        "detail": "adjustText",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "PCA",
        "importPath": "sklearn.decomposition",
        "description": "sklearn.decomposition",
        "isExtraImport": true,
        "detail": "sklearn.decomposition",
        "documentation": {}
    },
    {
        "label": "StandardScaler",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "RobustScaler",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "PLSRegression",
        "importPath": "sklearn.cross_decomposition",
        "description": "sklearn.cross_decomposition",
        "isExtraImport": true,
        "detail": "sklearn.cross_decomposition",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "yaml",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "yaml",
        "description": "yaml",
        "detail": "yaml",
        "documentation": {}
    },
    {
        "label": "PCAPlotMixin",
        "importPath": "src.plots.pca_plot",
        "description": "src.plots.pca_plot",
        "isExtraImport": true,
        "detail": "src.plots.pca_plot",
        "documentation": {}
    },
    {
        "label": "BoxplotMixin",
        "importPath": "src.plots.boxplot",
        "description": "src.plots.boxplot",
        "isExtraImport": true,
        "detail": "src.plots.boxplot",
        "documentation": {}
    },
    {
        "label": "HeatmapMixin",
        "importPath": "src.plots.heatmap",
        "description": "src.plots.heatmap",
        "isExtraImport": true,
        "detail": "src.plots.heatmap",
        "documentation": {}
    },
    {
        "label": "HistogramMixin",
        "importPath": "src.plots.histogram",
        "description": "src.plots.histogram",
        "isExtraImport": true,
        "detail": "src.plots.histogram",
        "documentation": {}
    },
    {
        "label": "VIPScorePlotMixin",
        "importPath": "src.plots.vip_score_plot",
        "description": "src.plots.vip_score_plot",
        "isExtraImport": true,
        "detail": "src.plots.vip_score_plot",
        "documentation": {}
    },
    {
        "label": "VIPScorePlotRMixin",
        "importPath": "src.plots.vip_score_plot_r",
        "description": "src.plots.vip_score_plot_r",
        "isExtraImport": true,
        "detail": "src.plots.vip_score_plot_r",
        "documentation": {}
    },
    {
        "label": "DistributionPlotMixin",
        "importPath": "src.plots.distribution_plot",
        "description": "src.plots.distribution_plot",
        "isExtraImport": true,
        "detail": "src.plots.distribution_plot",
        "documentation": {}
    },
    {
        "label": "VolcanoPlotMixin",
        "importPath": "src.plots.volcano_plot",
        "description": "src.plots.volcano_plot",
        "isExtraImport": true,
        "detail": "src.plots.volcano_plot",
        "documentation": {}
    },
    {
        "label": "SiteSpecificHeatmapMixin",
        "importPath": "src.plots.site_specific_heatmap",
        "description": "src.plots.site_specific_heatmap",
        "isExtraImport": true,
        "detail": "src.plots.site_specific_heatmap",
        "documentation": {}
    },
    {
        "label": "CVDistributionPlotMixin",
        "importPath": "src.plots.cv_distribution_plot",
        "description": "src.plots.cv_distribution_plot",
        "isExtraImport": true,
        "detail": "src.plots.cv_distribution_plot",
        "documentation": {}
    },
    {
        "label": "CorrelationMatrixPlotMixin",
        "importPath": "src.plots.correlation_matrix_plot",
        "description": "src.plots.correlation_matrix_plot",
        "isExtraImport": true,
        "detail": "src.plots.correlation_matrix_plot",
        "documentation": {}
    },
    {
        "label": "VennDiagramPlotMixin",
        "importPath": "src.plots.venn_diagram_plot",
        "description": "src.plots.venn_diagram_plot",
        "isExtraImport": true,
        "detail": "src.plots.venn_diagram_plot",
        "documentation": {}
    },
    {
        "label": "RadarChartPlotMixin",
        "importPath": "src.plots.radar_chart_plot",
        "description": "src.plots.radar_chart_plot",
        "isExtraImport": true,
        "detail": "src.plots.radar_chart_plot",
        "documentation": {}
    },
    {
        "label": "GlycopeptideDotHeatmapMixin",
        "importPath": "src.plots.glycopeptide_dot_heatmap",
        "description": "src.plots.glycopeptide_dot_heatmap",
        "isExtraImport": true,
        "detail": "src.plots.glycopeptide_dot_heatmap",
        "documentation": {}
    },
    {
        "label": "GlycopeptideComparisonHeatmapMixin",
        "importPath": "src.plots.glycopeptide_comparison_heatmap",
        "description": "src.plots.glycopeptide_comparison_heatmap",
        "isExtraImport": true,
        "detail": "src.plots.glycopeptide_comparison_heatmap",
        "documentation": {}
    },
    {
        "label": "load_and_validate_config",
        "importPath": "src.config_validator",
        "description": "src.config_validator",
        "isExtraImport": true,
        "detail": "src.config_validator",
        "documentation": {}
    },
    {
        "label": "setup_logging",
        "importPath": "src.logger_config",
        "description": "src.logger_config",
        "isExtraImport": true,
        "detail": "src.logger_config",
        "documentation": {}
    },
    {
        "label": "get_logger",
        "importPath": "src.logger_config",
        "description": "src.logger_config",
        "isExtraImport": true,
        "detail": "src.logger_config",
        "documentation": {}
    },
    {
        "label": "DataLoader",
        "importPath": "src.data_loader",
        "description": "src.data_loader",
        "isExtraImport": true,
        "detail": "src.data_loader",
        "documentation": {}
    },
    {
        "label": "GlycanAnnotator",
        "importPath": "src.annotator",
        "description": "src.annotator",
        "isExtraImport": true,
        "detail": "src.annotator",
        "documentation": {}
    },
    {
        "label": "GlycanAnalyzer",
        "importPath": "src.analyzer",
        "description": "src.analyzer",
        "isExtraImport": true,
        "detail": "src.analyzer",
        "documentation": {}
    },
    {
        "label": "GlycanVisualizer",
        "importPath": "src.visualizer",
        "description": "src.visualizer",
        "isExtraImport": true,
        "detail": "src.visualizer",
        "documentation": {}
    },
    {
        "label": "PGlycoAutoError",
        "importPath": "src.exceptions",
        "description": "src.exceptions",
        "isExtraImport": true,
        "detail": "src.exceptions",
        "documentation": {}
    },
    {
        "label": "OUTPUT_INTEGRATED",
        "importPath": "src.constants",
        "description": "src.constants",
        "isExtraImport": true,
        "detail": "src.constants",
        "documentation": {}
    },
    {
        "label": "OUTPUT_STATISTICS",
        "importPath": "src.constants",
        "description": "src.constants",
        "isExtraImport": true,
        "detail": "src.constants",
        "documentation": {}
    },
    {
        "label": "OUTPUT_VIP_SCORES",
        "importPath": "src.constants",
        "description": "src.constants",
        "isExtraImport": true,
        "detail": "src.constants",
        "documentation": {}
    },
    {
        "label": "OUTPUT_SUMMARY",
        "importPath": "src.constants",
        "description": "src.constants",
        "isExtraImport": true,
        "detail": "src.constants",
        "documentation": {}
    },
    {
        "label": "verify_heatmap_data",
        "kind": 2,
        "importPath": "scripts.verify_trace_data",
        "description": "scripts.verify_trace_data",
        "peekOfCode": "def verify_heatmap_data():\n    \"\"\"Comprehensive verification of trace data\"\"\"\n    print(\"=\"*80)\n    print(\"Verification of Glycopeptide Comparison Heatmap Trace Data\")\n    print(\"=\"*80)\n    # Check if files exist\n    summary_path = Path('Results/Trace/glycopeptide_comparison_heatmap_summary.csv')\n    full_data_path = Path('Results/Trace/glycopeptide_comparison_heatmap_data.csv')\n    if not summary_path.exists():\n        print(f\"\\n❌ ERROR: Summary file not found at {summary_path}\")",
        "detail": "scripts.verify_trace_data",
        "documentation": {}
    },
    {
        "label": "BoxplotMixin",
        "kind": 6,
        "importPath": "src.plots.boxplot",
        "description": "src.plots.boxplot",
        "peekOfCode": "class BoxplotMixin:\n    \"\"\"Mixin class for boxplot-related visualizations\"\"\"\n    def plot_boxplot(self, boxplot_data: pd.DataFrame, figsize: tuple = (12, 6)):\n        \"\"\"\n        Create boxplot comparing glycan types between groups with statistical significance\n        Args:\n            boxplot_data: Long-format DataFrame from analyzer\n            figsize: Figure size\n        \"\"\"\n        fig, ax = plt.subplots(figsize=figsize)",
        "detail": "src.plots.boxplot",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.plots.boxplot",
        "description": "src.plots.boxplot",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass BoxplotMixin:\n    \"\"\"Mixin class for boxplot-related visualizations\"\"\"\n    def plot_boxplot(self, boxplot_data: pd.DataFrame, figsize: tuple = (12, 6)):\n        \"\"\"\n        Create boxplot comparing glycan types between groups with statistical significance\n        Args:\n            boxplot_data: Long-format DataFrame from analyzer\n            figsize: Figure size\n        \"\"\"",
        "detail": "src.plots.boxplot",
        "documentation": {}
    },
    {
        "label": "CorrelationMatrixPlotMixin",
        "kind": 6,
        "importPath": "src.plots.correlation_matrix_plot",
        "description": "src.plots.correlation_matrix_plot",
        "peekOfCode": "class CorrelationMatrixPlotMixin:\n    \"\"\"Mixin class for correlation matrix visualization\"\"\"\n    def plot_correlation_matrix(self, df: pd.DataFrame, figsize: tuple = (20, 18)):\n        \"\"\"\n        Create correlation matrix heatmap for samples\n        Args:\n            df: Annotated DataFrame with intensity data\n            figsize: Figure size (width, height)\n        \"\"\"\n        # Get sample columns",
        "detail": "src.plots.correlation_matrix_plot",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.plots.correlation_matrix_plot",
        "description": "src.plots.correlation_matrix_plot",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass CorrelationMatrixPlotMixin:\n    \"\"\"Mixin class for correlation matrix visualization\"\"\"\n    def plot_correlation_matrix(self, df: pd.DataFrame, figsize: tuple = (20, 18)):\n        \"\"\"\n        Create correlation matrix heatmap for samples\n        Args:\n            df: Annotated DataFrame with intensity data\n            figsize: Figure size (width, height)\n        \"\"\"",
        "detail": "src.plots.correlation_matrix_plot",
        "documentation": {}
    },
    {
        "label": "CVDistributionPlotMixin",
        "kind": 6,
        "importPath": "src.plots.cv_distribution_plot",
        "description": "src.plots.cv_distribution_plot",
        "peekOfCode": "class CVDistributionPlotMixin:\n    \"\"\"Mixin class for CV distribution visualization\"\"\"\n    def plot_cv_distribution(self, df: pd.DataFrame, figsize: tuple = (14, 6)):\n        \"\"\"\n        Create CV (Coefficient of Variation) distribution plots for Cancer and Normal samples\n        Args:\n            df: Annotated DataFrame with intensity data\n            figsize: Figure size (width, height)\n        \"\"\"\n        # Get sample columns",
        "detail": "src.plots.cv_distribution_plot",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.plots.cv_distribution_plot",
        "description": "src.plots.cv_distribution_plot",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass CVDistributionPlotMixin:\n    \"\"\"Mixin class for CV distribution visualization\"\"\"\n    def plot_cv_distribution(self, df: pd.DataFrame, figsize: tuple = (14, 6)):\n        \"\"\"\n        Create CV (Coefficient of Variation) distribution plots for Cancer and Normal samples\n        Args:\n            df: Annotated DataFrame with intensity data\n            figsize: Figure size (width, height)\n        \"\"\"",
        "detail": "src.plots.cv_distribution_plot",
        "documentation": {}
    },
    {
        "label": "DistributionPlotMixin",
        "kind": 6,
        "importPath": "src.plots.distribution_plot",
        "description": "src.plots.distribution_plot",
        "peekOfCode": "class DistributionPlotMixin:\n    \"\"\"Mixin class for distribution-related plots\"\"\"\n    def plot_glycan_type_distribution(self, df: pd.DataFrame, figsize: tuple = (10, 6)):\n        \"\"\"\n        Create bar plot showing distribution of glycan types\n        Args:\n            df: Annotated DataFrame\n            figsize: Figure size\n        \"\"\"\n        fig, ax = plt.subplots(figsize=figsize)",
        "detail": "src.plots.distribution_plot",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.plots.distribution_plot",
        "description": "src.plots.distribution_plot",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass DistributionPlotMixin:\n    \"\"\"Mixin class for distribution-related plots\"\"\"\n    def plot_glycan_type_distribution(self, df: pd.DataFrame, figsize: tuple = (10, 6)):\n        \"\"\"\n        Create bar plot showing distribution of glycan types\n        Args:\n            df: Annotated DataFrame\n            figsize: Figure size\n        \"\"\"",
        "detail": "src.plots.distribution_plot",
        "documentation": {}
    },
    {
        "label": "GlycopeptideComparisonHeatmapMixin",
        "kind": 6,
        "importPath": "src.plots.glycopeptide_comparison_heatmap",
        "description": "src.plots.glycopeptide_comparison_heatmap",
        "peekOfCode": "class GlycopeptideComparisonHeatmapMixin:\n    \"\"\"Mixin class for glycopeptide comparison heatmap (Cancer vs Normal)\"\"\"\n    def plot_glycopeptide_comparison_heatmap(\n        self,\n        df: pd.DataFrame,\n        vip_scores: pd.DataFrame,\n        figsize: tuple = (24, 16),\n        max_peptides: int = 50,\n        max_glycans_per_type: int = 15\n    ):",
        "detail": "src.plots.glycopeptide_comparison_heatmap",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.plots.glycopeptide_comparison_heatmap",
        "description": "src.plots.glycopeptide_comparison_heatmap",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass GlycopeptideComparisonHeatmapMixin:\n    \"\"\"Mixin class for glycopeptide comparison heatmap (Cancer vs Normal)\"\"\"\n    def plot_glycopeptide_comparison_heatmap(\n        self,\n        df: pd.DataFrame,\n        vip_scores: pd.DataFrame,\n        figsize: tuple = (24, 16),\n        max_peptides: int = 50,\n        max_glycans_per_type: int = 15",
        "detail": "src.plots.glycopeptide_comparison_heatmap",
        "documentation": {}
    },
    {
        "label": "GlycopeptideDotHeatmapMixin",
        "kind": 6,
        "importPath": "src.plots.glycopeptide_dot_heatmap",
        "description": "src.plots.glycopeptide_dot_heatmap",
        "peekOfCode": "class GlycopeptideDotHeatmapMixin:\n    \"\"\"Mixin class for glycopeptide dot heatmap visualization\"\"\"\n    def plot_glycopeptide_dot_heatmap(\n        self,\n        df: pd.DataFrame,\n        vip_scores: pd.DataFrame,\n        sample_name: str,\n        figsize: tuple = (20, 14),\n        max_peptides: int = 50,\n        max_glycans_per_type: int = 20",
        "detail": "src.plots.glycopeptide_dot_heatmap",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.plots.glycopeptide_dot_heatmap",
        "description": "src.plots.glycopeptide_dot_heatmap",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass GlycopeptideDotHeatmapMixin:\n    \"\"\"Mixin class for glycopeptide dot heatmap visualization\"\"\"\n    def plot_glycopeptide_dot_heatmap(\n        self,\n        df: pd.DataFrame,\n        vip_scores: pd.DataFrame,\n        sample_name: str,\n        figsize: tuple = (20, 14),\n        max_peptides: int = 50,",
        "detail": "src.plots.glycopeptide_dot_heatmap",
        "documentation": {}
    },
    {
        "label": "HeatmapMixin",
        "kind": 6,
        "importPath": "src.plots.heatmap",
        "description": "src.plots.heatmap",
        "peekOfCode": "class HeatmapMixin:\n    \"\"\"Mixin class for heatmap-related plots\"\"\"\n    def plot_heatmap(self, df: pd.DataFrame, figsize: tuple = (16, 12), top_n: int = 50):\n        \"\"\"\n        Create clustered heatmap of top glycopeptides with hierarchical clustering\n        Pipeline: TIC Normalization → Log2 Transform → Hierarchical Clustering\n        Args:\n            df: Annotated DataFrame\n            figsize: Figure size\n            top_n: Number of top glycopeptides to show",
        "detail": "src.plots.heatmap",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.plots.heatmap",
        "description": "src.plots.heatmap",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass HeatmapMixin:\n    \"\"\"Mixin class for heatmap-related plots\"\"\"\n    def plot_heatmap(self, df: pd.DataFrame, figsize: tuple = (16, 12), top_n: int = 50):\n        \"\"\"\n        Create clustered heatmap of top glycopeptides with hierarchical clustering\n        Pipeline: TIC Normalization → Log2 Transform → Hierarchical Clustering\n        Args:\n            df: Annotated DataFrame\n            figsize: Figure size",
        "detail": "src.plots.heatmap",
        "documentation": {}
    },
    {
        "label": "HistogramMixin",
        "kind": 6,
        "importPath": "src.plots.histogram",
        "description": "src.plots.histogram",
        "peekOfCode": "class HistogramMixin:\n    \"\"\"Mixin class for histogram-related plots\"\"\"\n    def plot_histogram_normalized(self, df: pd.DataFrame, figsize: tuple = (20, 12)):\n        \"\"\"\n        Create histogram showing glycan type intensities per sample (TIC normalized data)\n        Args:\n            df: Annotated DataFrame\n            figsize: Figure size\n        \"\"\"\n        # Identify sample columns",
        "detail": "src.plots.histogram",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.plots.histogram",
        "description": "src.plots.histogram",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass HistogramMixin:\n    \"\"\"Mixin class for histogram-related plots\"\"\"\n    def plot_histogram_normalized(self, df: pd.DataFrame, figsize: tuple = (20, 12)):\n        \"\"\"\n        Create histogram showing glycan type intensities per sample (TIC normalized data)\n        Args:\n            df: Annotated DataFrame\n            figsize: Figure size\n        \"\"\"",
        "detail": "src.plots.histogram",
        "documentation": {}
    },
    {
        "label": "PCAPlotMixin",
        "kind": 6,
        "importPath": "src.plots.pca_plot",
        "description": "src.plots.pca_plot",
        "peekOfCode": "class PCAPlotMixin:\n    \"\"\"Mixin class for PCA-related plots\"\"\"\n    def _draw_confidence_ellipse(self, ax, x, y, color, alpha=0.2, n_std=1.96):\n        \"\"\"\n        Draw 95% confidence ellipse for a group of points\n        Args:\n            ax: Matplotlib axis\n            x, y: Data points\n            color: Ellipse color\n            alpha: Transparency",
        "detail": "src.plots.pca_plot",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.plots.pca_plot",
        "description": "src.plots.pca_plot",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass PCAPlotMixin:\n    \"\"\"Mixin class for PCA-related plots\"\"\"\n    def _draw_confidence_ellipse(self, ax, x, y, color, alpha=0.2, n_std=1.96):\n        \"\"\"\n        Draw 95% confidence ellipse for a group of points\n        Args:\n            ax: Matplotlib axis\n            x, y: Data points\n            color: Ellipse color",
        "detail": "src.plots.pca_plot",
        "documentation": {}
    },
    {
        "label": "RadarChartPlotMixin",
        "kind": 6,
        "importPath": "src.plots.radar_chart_plot",
        "description": "src.plots.radar_chart_plot",
        "peekOfCode": "class RadarChartPlotMixin:\n    \"\"\"Mixin class for radar/spider chart visualization\"\"\"\n    def plot_radar_chart(self, df: pd.DataFrame, figsize: tuple = (12, 10)):\n        \"\"\"\n        Create radar chart comparing glycan profiles between Cancer and Normal\n        Args:\n            df: Annotated DataFrame with intensity data\n            figsize: Figure size (width, height)\n        \"\"\"\n        # Get sample columns",
        "detail": "src.plots.radar_chart_plot",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.plots.radar_chart_plot",
        "description": "src.plots.radar_chart_plot",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass RadarChartPlotMixin:\n    \"\"\"Mixin class for radar/spider chart visualization\"\"\"\n    def plot_radar_chart(self, df: pd.DataFrame, figsize: tuple = (12, 10)):\n        \"\"\"\n        Create radar chart comparing glycan profiles between Cancer and Normal\n        Args:\n            df: Annotated DataFrame with intensity data\n            figsize: Figure size (width, height)\n        \"\"\"",
        "detail": "src.plots.radar_chart_plot",
        "documentation": {}
    },
    {
        "label": "SiteSpecificHeatmapMixin",
        "kind": 6,
        "importPath": "src.plots.site_specific_heatmap",
        "description": "src.plots.site_specific_heatmap",
        "peekOfCode": "class SiteSpecificHeatmapMixin:\n    \"\"\"Mixin class for site-specific glycosylation heatmap\"\"\"\n    def plot_site_specific_heatmap(self, df: pd.DataFrame, vip_df: pd.DataFrame,\n                                   top_n_peptides: int = 20,\n                                   figsize: tuple = (16, 12)):\n        \"\"\"\n        Create heatmap showing glycan compositions for top peptides\n        Args:\n            df: Annotated DataFrame with intensity data\n            vip_df: DataFrame with VIP scores",
        "detail": "src.plots.site_specific_heatmap",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.plots.site_specific_heatmap",
        "description": "src.plots.site_specific_heatmap",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass SiteSpecificHeatmapMixin:\n    \"\"\"Mixin class for site-specific glycosylation heatmap\"\"\"\n    def plot_site_specific_heatmap(self, df: pd.DataFrame, vip_df: pd.DataFrame,\n                                   top_n_peptides: int = 20,\n                                   figsize: tuple = (16, 12)):\n        \"\"\"\n        Create heatmap showing glycan compositions for top peptides\n        Args:\n            df: Annotated DataFrame with intensity data",
        "detail": "src.plots.site_specific_heatmap",
        "documentation": {}
    },
    {
        "label": "VennDiagramPlotMixin",
        "kind": 6,
        "importPath": "src.plots.venn_diagram_plot",
        "description": "src.plots.venn_diagram_plot",
        "peekOfCode": "class VennDiagramPlotMixin:\n    \"\"\"Mixin class for Venn diagram visualization\"\"\"\n    def plot_glycan_venn_diagram(self, df: pd.DataFrame, figsize: tuple = (12, 10)):\n        \"\"\"\n        Create Venn diagram showing overlap between glycan modification types\n        Args:\n            df: Annotated DataFrame with glycan annotations\n            figsize: Figure size (width, height)\n        \"\"\"\n        # Check if internal columns exist",
        "detail": "src.plots.venn_diagram_plot",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.plots.venn_diagram_plot",
        "description": "src.plots.venn_diagram_plot",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass VennDiagramPlotMixin:\n    \"\"\"Mixin class for Venn diagram visualization\"\"\"\n    def plot_glycan_venn_diagram(self, df: pd.DataFrame, figsize: tuple = (12, 10)):\n        \"\"\"\n        Create Venn diagram showing overlap between glycan modification types\n        Args:\n            df: Annotated DataFrame with glycan annotations\n            figsize: Figure size (width, height)\n        \"\"\"",
        "detail": "src.plots.venn_diagram_plot",
        "documentation": {}
    },
    {
        "label": "VIPScorePlotMixin",
        "kind": 6,
        "importPath": "src.plots.vip_score_plot",
        "description": "src.plots.vip_score_plot",
        "peekOfCode": "class VIPScorePlotMixin:\n    \"\"\"Mixin class for VIP score-related plots\"\"\"\n    def plot_vip_scores_glycopeptide(self, df: pd.DataFrame, vip_df: pd.DataFrame, figsize: tuple = (10, 6), top_n: int = 10):\n        \"\"\"\n        Plot top VIP scores by glycopeptide with heatmap showing Cancer/Normal intensity\n        Args:\n            df: Annotated DataFrame\n            vip_df: DataFrame with VIP scores by glycopeptide\n            figsize: Figure size\n            top_n: Number of top glycopeptides to show",
        "detail": "src.plots.vip_score_plot",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.plots.vip_score_plot",
        "description": "src.plots.vip_score_plot",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass VIPScorePlotMixin:\n    \"\"\"Mixin class for VIP score-related plots\"\"\"\n    def plot_vip_scores_glycopeptide(self, df: pd.DataFrame, vip_df: pd.DataFrame, figsize: tuple = (10, 6), top_n: int = 10):\n        \"\"\"\n        Plot top VIP scores by glycopeptide with heatmap showing Cancer/Normal intensity\n        Args:\n            df: Annotated DataFrame\n            vip_df: DataFrame with VIP scores by glycopeptide\n            figsize: Figure size",
        "detail": "src.plots.vip_score_plot",
        "documentation": {}
    },
    {
        "label": "VIPScorePlotRMixin",
        "kind": 6,
        "importPath": "src.plots.vip_score_plot_r",
        "description": "src.plots.vip_score_plot_r",
        "peekOfCode": "class VIPScorePlotRMixin:\n    \"\"\"Mixin class for R-based VIP score plots using ggplot2\"\"\"\n    def _create_vip_plot_r(self, vip_data: pd.DataFrame, heatmap_data: pd.DataFrame,\n                           title: str, ylabel: str, output_file: str):\n        \"\"\"\n        Create VIP score plot with ggplot2\n        Args:\n            vip_data: DataFrame with columns [Feature, VIP_Score]\n            heatmap_data: DataFrame with columns [Feature, Cancer, Normal]\n            title: Plot title",
        "detail": "src.plots.vip_score_plot_r",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.plots.vip_score_plot_r",
        "description": "src.plots.vip_score_plot_r",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass VIPScorePlotRMixin:\n    \"\"\"Mixin class for R-based VIP score plots using ggplot2\"\"\"\n    def _create_vip_plot_r(self, vip_data: pd.DataFrame, heatmap_data: pd.DataFrame,\n                           title: str, ylabel: str, output_file: str):\n        \"\"\"\n        Create VIP score plot with ggplot2\n        Args:\n            vip_data: DataFrame with columns [Feature, VIP_Score]\n            heatmap_data: DataFrame with columns [Feature, Cancer, Normal]",
        "detail": "src.plots.vip_score_plot_r",
        "documentation": {}
    },
    {
        "label": "VolcanoPlotMixin",
        "kind": 6,
        "importPath": "src.plots.volcano_plot",
        "description": "src.plots.volcano_plot",
        "peekOfCode": "class VolcanoPlotMixin:\n    \"\"\"Mixin class for Volcano plot visualization\"\"\"\n    def plot_volcano(self, df: pd.DataFrame, vip_df: pd.DataFrame,\n                     fdr_threshold: float = 0.05, fc_threshold: float = 1.5,\n                     figsize: tuple = (12, 10)):\n        \"\"\"\n        Create volcano plot showing log2(fold change) vs -log10(FDR)\n        Args:\n            df: Annotated DataFrame with intensity data\n            vip_df: DataFrame with VIP scores",
        "detail": "src.plots.volcano_plot",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.plots.volcano_plot",
        "description": "src.plots.volcano_plot",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass VolcanoPlotMixin:\n    \"\"\"Mixin class for Volcano plot visualization\"\"\"\n    def plot_volcano(self, df: pd.DataFrame, vip_df: pd.DataFrame,\n                     fdr_threshold: float = 0.05, fc_threshold: float = 1.5,\n                     figsize: tuple = (12, 10)):\n        \"\"\"\n        Create volcano plot showing log2(fold change) vs -log10(FDR)\n        Args:\n            df: Annotated DataFrame with intensity data",
        "detail": "src.plots.volcano_plot",
        "documentation": {}
    },
    {
        "label": "GlycanAnalyzer",
        "kind": 6,
        "importPath": "src.analyzer",
        "description": "src.analyzer",
        "peekOfCode": "class GlycanAnalyzer:\n    \"\"\"Perform statistical analysis on glycoproteomics data\"\"\"\n    def __init__(self,\n                 n_components: int = DEFAULT_PCA_COMPONENTS,\n                 log_transform: bool = DEFAULT_LOG_TRANSFORM):\n        \"\"\"\n        Initialize GlycanAnalyzer\n        Args:\n            n_components: Number of PCA components (default: 2)\n            log_transform: Whether to log-transform intensity values (default: True)",
        "detail": "src.analyzer",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.analyzer",
        "description": "src.analyzer",
        "peekOfCode": "logger = get_logger(__name__)\nclass GlycanAnalyzer:\n    \"\"\"Perform statistical analysis on glycoproteomics data\"\"\"\n    def __init__(self,\n                 n_components: int = DEFAULT_PCA_COMPONENTS,\n                 log_transform: bool = DEFAULT_LOG_TRANSFORM):\n        \"\"\"\n        Initialize GlycanAnalyzer\n        Args:\n            n_components: Number of PCA components (default: 2)",
        "detail": "src.analyzer",
        "documentation": {}
    },
    {
        "label": "GlycanAnnotator",
        "kind": 6,
        "importPath": "src.annotator",
        "description": "src.annotator",
        "peekOfCode": "class GlycanAnnotator:\n    \"\"\"Annotate glycopeptides based on glycan composition\"\"\"\n    def __init__(self,\n                 sialylation_marker: str = DEFAULT_SIALYLATION_MARKER,\n                 fucosylation_marker: str = DEFAULT_FUCOSYLATION_MARKER):\n        \"\"\"\n        Initialize GlycanAnnotator\n        Args:\n            sialylation_marker: Marker for sialylation (default: 'A' for NeuAc)\n            fucosylation_marker: Marker for fucosylation (default: 'F')",
        "detail": "src.annotator",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.annotator",
        "description": "src.annotator",
        "peekOfCode": "logger = get_logger(__name__)\nclass GlycanAnnotator:\n    \"\"\"Annotate glycopeptides based on glycan composition\"\"\"\n    def __init__(self,\n                 sialylation_marker: str = DEFAULT_SIALYLATION_MARKER,\n                 fucosylation_marker: str = DEFAULT_FUCOSYLATION_MARKER):\n        \"\"\"\n        Initialize GlycanAnnotator\n        Args:\n            sialylation_marker: Marker for sialylation (default: 'A' for NeuAc)",
        "detail": "src.annotator",
        "documentation": {}
    },
    {
        "label": "ConfigValidator",
        "kind": 6,
        "importPath": "src.config_validator",
        "description": "src.config_validator",
        "peekOfCode": "class ConfigValidator:\n    \"\"\"Validates configuration dictionary\"\"\"\n    # Required top-level keys\n    REQUIRED_KEYS = ['paths', 'processing', 'annotation', 'analysis', 'visualization']\n    # Required nested keys\n    REQUIRED_NESTED_KEYS = {\n        'paths': ['dataset_dir', 'results_dir', 'output_file'],\n        'processing': ['required_columns', 'qc_filters'],\n        'annotation': ['sialylation_marker', 'fucosylation_marker'],\n        'analysis': ['pca', 'statistical_tests'],",
        "detail": "src.config_validator",
        "documentation": {}
    },
    {
        "label": "load_and_validate_config",
        "kind": 2,
        "importPath": "src.config_validator",
        "description": "src.config_validator",
        "peekOfCode": "def load_and_validate_config(config_path: str) -> Dict[str, Any]:\n    \"\"\"\n    Load configuration from YAML file and validate it\n    Args:\n        config_path: Path to config.yaml file\n    Returns:\n        Validated configuration dictionary\n    Raises:\n        ConfigurationError: If config file is invalid or missing\n    \"\"\"",
        "detail": "src.config_validator",
        "documentation": {}
    },
    {
        "label": "DataLoader",
        "kind": 6,
        "importPath": "src.data_loader",
        "description": "src.data_loader",
        "peekOfCode": "class DataLoader:\n    \"\"\"Load and integrate glycoproteomics data from multiple CSV files\"\"\"\n    def __init__(self, dataset_dir: str, required_columns: List[str]):\n        \"\"\"\n        Initialize DataLoader\n        Args:\n            dataset_dir: Path to directory containing CSV files\n            required_columns: List of required column names\n        \"\"\"\n        self.dataset_dir = Path(dataset_dir)",
        "detail": "src.data_loader",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.data_loader",
        "description": "src.data_loader",
        "peekOfCode": "logger = get_logger(__name__)\nclass DataLoader:\n    \"\"\"Load and integrate glycoproteomics data from multiple CSV files\"\"\"\n    def __init__(self, dataset_dir: str, required_columns: List[str]):\n        \"\"\"\n        Initialize DataLoader\n        Args:\n            dataset_dir: Path to directory containing CSV files\n            required_columns: List of required column names\n        \"\"\"",
        "detail": "src.data_loader",
        "documentation": {}
    },
    {
        "label": "PGlycoAutoError",
        "kind": 6,
        "importPath": "src.exceptions",
        "description": "src.exceptions",
        "peekOfCode": "class PGlycoAutoError(Exception):\n    \"\"\"Base exception for all pGlyco Auto Combine errors\"\"\"\n    pass\n# ==============================================================================\n# Configuration Errors\n# ==============================================================================\nclass ConfigurationError(PGlycoAutoError):\n    \"\"\"Raised when configuration is invalid or missing\"\"\"\n    pass\nclass MissingConfigKeyError(ConfigurationError):",
        "detail": "src.exceptions",
        "documentation": {}
    },
    {
        "label": "ConfigurationError",
        "kind": 6,
        "importPath": "src.exceptions",
        "description": "src.exceptions",
        "peekOfCode": "class ConfigurationError(PGlycoAutoError):\n    \"\"\"Raised when configuration is invalid or missing\"\"\"\n    pass\nclass MissingConfigKeyError(ConfigurationError):\n    \"\"\"Raised when a required configuration key is missing\"\"\"\n    def __init__(self, key: str):\n        self.key = key\n        super().__init__(f\"Missing required configuration key: {key}\")\nclass InvalidConfigValueError(ConfigurationError):\n    \"\"\"Raised when a configuration value is invalid\"\"\"",
        "detail": "src.exceptions",
        "documentation": {}
    },
    {
        "label": "MissingConfigKeyError",
        "kind": 6,
        "importPath": "src.exceptions",
        "description": "src.exceptions",
        "peekOfCode": "class MissingConfigKeyError(ConfigurationError):\n    \"\"\"Raised when a required configuration key is missing\"\"\"\n    def __init__(self, key: str):\n        self.key = key\n        super().__init__(f\"Missing required configuration key: {key}\")\nclass InvalidConfigValueError(ConfigurationError):\n    \"\"\"Raised when a configuration value is invalid\"\"\"\n    def __init__(self, key: str, value, reason: str = \"\"):\n        self.key = key\n        self.value = value",
        "detail": "src.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidConfigValueError",
        "kind": 6,
        "importPath": "src.exceptions",
        "description": "src.exceptions",
        "peekOfCode": "class InvalidConfigValueError(ConfigurationError):\n    \"\"\"Raised when a configuration value is invalid\"\"\"\n    def __init__(self, key: str, value, reason: str = \"\"):\n        self.key = key\n        self.value = value\n        self.reason = reason\n        message = f\"Invalid configuration value for '{key}': {value}\"\n        if reason:\n            message += f\" - {reason}\"\n        super().__init__(message)",
        "detail": "src.exceptions",
        "documentation": {}
    },
    {
        "label": "DataLoadError",
        "kind": 6,
        "importPath": "src.exceptions",
        "description": "src.exceptions",
        "peekOfCode": "class DataLoadError(PGlycoAutoError):\n    \"\"\"Raised when data loading fails\"\"\"\n    pass\nclass NoDataFilesError(DataLoadError):\n    \"\"\"Raised when no CSV files are found in the dataset directory\"\"\"\n    def __init__(self, directory: str):\n        self.directory = directory\n        super().__init__(f\"No CSV files found in directory: {directory}\")\nclass MissingColumnError(DataLoadError):\n    \"\"\"Raised when required columns are missing from input data\"\"\"",
        "detail": "src.exceptions",
        "documentation": {}
    },
    {
        "label": "NoDataFilesError",
        "kind": 6,
        "importPath": "src.exceptions",
        "description": "src.exceptions",
        "peekOfCode": "class NoDataFilesError(DataLoadError):\n    \"\"\"Raised when no CSV files are found in the dataset directory\"\"\"\n    def __init__(self, directory: str):\n        self.directory = directory\n        super().__init__(f\"No CSV files found in directory: {directory}\")\nclass MissingColumnError(DataLoadError):\n    \"\"\"Raised when required columns are missing from input data\"\"\"\n    def __init__(self, filename: str, missing_columns: list):\n        self.filename = filename\n        self.missing_columns = missing_columns",
        "detail": "src.exceptions",
        "documentation": {}
    },
    {
        "label": "MissingColumnError",
        "kind": 6,
        "importPath": "src.exceptions",
        "description": "src.exceptions",
        "peekOfCode": "class MissingColumnError(DataLoadError):\n    \"\"\"Raised when required columns are missing from input data\"\"\"\n    def __init__(self, filename: str, missing_columns: list):\n        self.filename = filename\n        self.missing_columns = missing_columns\n        super().__init__(\n            f\"Missing required columns in {filename}: {', '.join(missing_columns)}\"\n        )\nclass InvalidDataFormatError(DataLoadError):\n    \"\"\"Raised when data format is invalid\"\"\"",
        "detail": "src.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidDataFormatError",
        "kind": 6,
        "importPath": "src.exceptions",
        "description": "src.exceptions",
        "peekOfCode": "class InvalidDataFormatError(DataLoadError):\n    \"\"\"Raised when data format is invalid\"\"\"\n    def __init__(self, filename: str, reason: str):\n        self.filename = filename\n        self.reason = reason\n        super().__init__(f\"Invalid data format in {filename}: {reason}\")\nclass EmptyDataError(DataLoadError):\n    \"\"\"Raised when no valid data is loaded\"\"\"\n    def __init__(self, context: str = \"\"):\n        message = \"No valid data loaded\"",
        "detail": "src.exceptions",
        "documentation": {}
    },
    {
        "label": "EmptyDataError",
        "kind": 6,
        "importPath": "src.exceptions",
        "description": "src.exceptions",
        "peekOfCode": "class EmptyDataError(DataLoadError):\n    \"\"\"Raised when no valid data is loaded\"\"\"\n    def __init__(self, context: str = \"\"):\n        message = \"No valid data loaded\"\n        if context:\n            message += f\": {context}\"\n        super().__init__(message)\n# ==============================================================================\n# Annotation Errors\n# ==============================================================================",
        "detail": "src.exceptions",
        "documentation": {}
    },
    {
        "label": "AnnotationError",
        "kind": 6,
        "importPath": "src.exceptions",
        "description": "src.exceptions",
        "peekOfCode": "class AnnotationError(PGlycoAutoError):\n    \"\"\"Raised when annotation fails\"\"\"\n    pass\nclass InvalidGlycanCompositionError(AnnotationError):\n    \"\"\"Raised when glycan composition string is invalid\"\"\"\n    def __init__(self, composition: str, reason: str = \"\"):\n        self.composition = composition\n        self.reason = reason\n        message = f\"Invalid glycan composition: {composition}\"\n        if reason:",
        "detail": "src.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidGlycanCompositionError",
        "kind": 6,
        "importPath": "src.exceptions",
        "description": "src.exceptions",
        "peekOfCode": "class InvalidGlycanCompositionError(AnnotationError):\n    \"\"\"Raised when glycan composition string is invalid\"\"\"\n    def __init__(self, composition: str, reason: str = \"\"):\n        self.composition = composition\n        self.reason = reason\n        message = f\"Invalid glycan composition: {composition}\"\n        if reason:\n            message += f\" - {reason}\"\n        super().__init__(message)\n# ==============================================================================",
        "detail": "src.exceptions",
        "documentation": {}
    },
    {
        "label": "AnalysisError",
        "kind": 6,
        "importPath": "src.exceptions",
        "description": "src.exceptions",
        "peekOfCode": "class AnalysisError(PGlycoAutoError):\n    \"\"\"Raised when statistical analysis fails\"\"\"\n    pass\nclass InsufficientDataError(AnalysisError):\n    \"\"\"Raised when insufficient data for analysis\"\"\"\n    def __init__(self, analysis_type: str, required: int, actual: int):\n        self.analysis_type = analysis_type\n        self.required = required\n        self.actual = actual\n        super().__init__(",
        "detail": "src.exceptions",
        "documentation": {}
    },
    {
        "label": "InsufficientDataError",
        "kind": 6,
        "importPath": "src.exceptions",
        "description": "src.exceptions",
        "peekOfCode": "class InsufficientDataError(AnalysisError):\n    \"\"\"Raised when insufficient data for analysis\"\"\"\n    def __init__(self, analysis_type: str, required: int, actual: int):\n        self.analysis_type = analysis_type\n        self.required = required\n        self.actual = actual\n        super().__init__(\n            f\"Insufficient data for {analysis_type}: \"\n            f\"required {required}, got {actual}\"\n        )",
        "detail": "src.exceptions",
        "documentation": {}
    },
    {
        "label": "MatrixShapeError",
        "kind": 6,
        "importPath": "src.exceptions",
        "description": "src.exceptions",
        "peekOfCode": "class MatrixShapeError(AnalysisError):\n    \"\"\"Raised when matrix dimensions are incompatible\"\"\"\n    def __init__(self, expected_shape: tuple, actual_shape: tuple, context: str = \"\"):\n        self.expected_shape = expected_shape\n        self.actual_shape = actual_shape\n        message = f\"Matrix shape mismatch: expected {expected_shape}, got {actual_shape}\"\n        if context:\n            message += f\" - {context}\"\n        super().__init__(message)\nclass NormalizationError(AnalysisError):",
        "detail": "src.exceptions",
        "documentation": {}
    },
    {
        "label": "NormalizationError",
        "kind": 6,
        "importPath": "src.exceptions",
        "description": "src.exceptions",
        "peekOfCode": "class NormalizationError(AnalysisError):\n    \"\"\"Raised when normalization fails\"\"\"\n    def __init__(self, reason: str):\n        super().__init__(f\"Normalization failed: {reason}\")\n# ==============================================================================\n# Visualization Errors\n# ==============================================================================\nclass VisualizationError(PGlycoAutoError):\n    \"\"\"Raised when visualization generation fails\"\"\"\n    pass",
        "detail": "src.exceptions",
        "documentation": {}
    },
    {
        "label": "VisualizationError",
        "kind": 6,
        "importPath": "src.exceptions",
        "description": "src.exceptions",
        "peekOfCode": "class VisualizationError(PGlycoAutoError):\n    \"\"\"Raised when visualization generation fails\"\"\"\n    pass\nclass PlotGenerationError(VisualizationError):\n    \"\"\"Raised when a specific plot fails to generate\"\"\"\n    def __init__(self, plot_type: str, reason: str):\n        self.plot_type = plot_type\n        self.reason = reason\n        super().__init__(f\"Failed to generate {plot_type}: {reason}\")\nclass MissingVisualizationDataError(VisualizationError):",
        "detail": "src.exceptions",
        "documentation": {}
    },
    {
        "label": "PlotGenerationError",
        "kind": 6,
        "importPath": "src.exceptions",
        "description": "src.exceptions",
        "peekOfCode": "class PlotGenerationError(VisualizationError):\n    \"\"\"Raised when a specific plot fails to generate\"\"\"\n    def __init__(self, plot_type: str, reason: str):\n        self.plot_type = plot_type\n        self.reason = reason\n        super().__init__(f\"Failed to generate {plot_type}: {reason}\")\nclass MissingVisualizationDataError(VisualizationError):\n    \"\"\"Raised when required data for visualization is missing\"\"\"\n    def __init__(self, plot_type: str, missing_data: str):\n        self.plot_type = plot_type",
        "detail": "src.exceptions",
        "documentation": {}
    },
    {
        "label": "MissingVisualizationDataError",
        "kind": 6,
        "importPath": "src.exceptions",
        "description": "src.exceptions",
        "peekOfCode": "class MissingVisualizationDataError(VisualizationError):\n    \"\"\"Raised when required data for visualization is missing\"\"\"\n    def __init__(self, plot_type: str, missing_data: str):\n        self.plot_type = plot_type\n        self.missing_data = missing_data\n        super().__init__(\n            f\"Missing required data for {plot_type}: {missing_data}\"\n        )\n# ==============================================================================\n# File I/O Errors",
        "detail": "src.exceptions",
        "documentation": {}
    },
    {
        "label": "FileOperationError",
        "kind": 6,
        "importPath": "src.exceptions",
        "description": "src.exceptions",
        "peekOfCode": "class FileOperationError(PGlycoAutoError):\n    \"\"\"Raised when file operations fail\"\"\"\n    pass\nclass OutputDirectoryError(FileOperationError):\n    \"\"\"Raised when output directory cannot be created or accessed\"\"\"\n    def __init__(self, directory: str, reason: str):\n        self.directory = directory\n        self.reason = reason\n        super().__init__(\n            f\"Cannot access/create output directory {directory}: {reason}\"",
        "detail": "src.exceptions",
        "documentation": {}
    },
    {
        "label": "OutputDirectoryError",
        "kind": 6,
        "importPath": "src.exceptions",
        "description": "src.exceptions",
        "peekOfCode": "class OutputDirectoryError(FileOperationError):\n    \"\"\"Raised when output directory cannot be created or accessed\"\"\"\n    def __init__(self, directory: str, reason: str):\n        self.directory = directory\n        self.reason = reason\n        super().__init__(\n            f\"Cannot access/create output directory {directory}: {reason}\"\n        )\nclass TraceDataSaveError(FileOperationError):\n    \"\"\"Raised when trace data cannot be saved\"\"\"",
        "detail": "src.exceptions",
        "documentation": {}
    },
    {
        "label": "TraceDataSaveError",
        "kind": 6,
        "importPath": "src.exceptions",
        "description": "src.exceptions",
        "peekOfCode": "class TraceDataSaveError(FileOperationError):\n    \"\"\"Raised when trace data cannot be saved\"\"\"\n    def __init__(self, filename: str, reason: str):\n        self.filename = filename\n        self.reason = reason\n        super().__init__(f\"Failed to save trace data {filename}: {reason}\")\n# ==============================================================================\n# Validation Errors\n# ==============================================================================\nclass ValidationError(PGlycoAutoError):",
        "detail": "src.exceptions",
        "documentation": {}
    },
    {
        "label": "ValidationError",
        "kind": 6,
        "importPath": "src.exceptions",
        "description": "src.exceptions",
        "peekOfCode": "class ValidationError(PGlycoAutoError):\n    \"\"\"Raised when data validation fails\"\"\"\n    pass\nclass SampleCountMismatchError(ValidationError):\n    \"\"\"Raised when sample counts don't match expected values\"\"\"\n    def __init__(self, expected: int, actual: int, sample_type: str = \"\"):\n        self.expected = expected\n        self.actual = actual\n        self.sample_type = sample_type\n        message = f\"Sample count mismatch: expected {expected}, got {actual}\"",
        "detail": "src.exceptions",
        "documentation": {}
    },
    {
        "label": "SampleCountMismatchError",
        "kind": 6,
        "importPath": "src.exceptions",
        "description": "src.exceptions",
        "peekOfCode": "class SampleCountMismatchError(ValidationError):\n    \"\"\"Raised when sample counts don't match expected values\"\"\"\n    def __init__(self, expected: int, actual: int, sample_type: str = \"\"):\n        self.expected = expected\n        self.actual = actual\n        self.sample_type = sample_type\n        message = f\"Sample count mismatch: expected {expected}, got {actual}\"\n        if sample_type:\n            message += f\" for {sample_type}\"\n        super().__init__(message)",
        "detail": "src.exceptions",
        "documentation": {}
    },
    {
        "label": "ValueRangeError",
        "kind": 6,
        "importPath": "src.exceptions",
        "description": "src.exceptions",
        "peekOfCode": "class ValueRangeError(ValidationError):\n    \"\"\"Raised when values are outside expected range\"\"\"\n    def __init__(self, value, min_val, max_val, field_name: str = \"\"):\n        self.value = value\n        self.min_val = min_val\n        self.max_val = max_val\n        message = f\"Value {value} outside valid range [{min_val}, {max_val}]\"\n        if field_name:\n            message = f\"{field_name}: {message}\"\n        super().__init__(message)",
        "detail": "src.exceptions",
        "documentation": {}
    },
    {
        "label": "setup_logging",
        "kind": 2,
        "importPath": "src.logger_config",
        "description": "src.logger_config",
        "peekOfCode": "def setup_logging(level: str = LOG_LEVEL_INFO,\n                 log_file: Optional[Path] = None,\n                 console: bool = True) -> None:\n    \"\"\"\n    Configure logging for the entire application\n    Should be called once at the start of the application.\n    Subsequent calls will be ignored to prevent reconfiguration.\n    Args:\n        level: Logging level (INFO, DEBUG, WARNING, ERROR)\n        log_file: Optional path to log file for file output",
        "detail": "src.logger_config",
        "documentation": {}
    },
    {
        "label": "get_logger",
        "kind": 2,
        "importPath": "src.logger_config",
        "description": "src.logger_config",
        "peekOfCode": "def get_logger(name: str) -> logging.Logger:\n    \"\"\"\n    Get a logger instance for a specific module\n    Args:\n        name: Name of the logger (typically __name__)\n    Returns:\n        Logger instance\n    \"\"\"\n    return logging.getLogger(name)\ndef reset_logging() -> None:",
        "detail": "src.logger_config",
        "documentation": {}
    },
    {
        "label": "reset_logging",
        "kind": 2,
        "importPath": "src.logger_config",
        "description": "src.logger_config",
        "peekOfCode": "def reset_logging() -> None:\n    \"\"\"\n    Reset logging configuration (mainly for testing)\n    \"\"\"\n    global _logging_configured\n    _logging_configured = False\n    root_logger = logging.getLogger()\n    root_logger.handlers = []",
        "detail": "src.logger_config",
        "documentation": {}
    },
    {
        "label": "_logging_configured",
        "kind": 5,
        "importPath": "src.logger_config",
        "description": "src.logger_config",
        "peekOfCode": "_logging_configured = False\ndef setup_logging(level: str = LOG_LEVEL_INFO,\n                 log_file: Optional[Path] = None,\n                 console: bool = True) -> None:\n    \"\"\"\n    Configure logging for the entire application\n    Should be called once at the start of the application.\n    Subsequent calls will be ignored to prevent reconfiguration.\n    Args:\n        level: Logging level (INFO, DEBUG, WARNING, ERROR)",
        "detail": "src.logger_config",
        "documentation": {}
    },
    {
        "label": "replace_empty_with_zero",
        "kind": 2,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "def replace_empty_with_zero(data: Union[pd.DataFrame, pd.Series]) -> Union[pd.DataFrame, pd.Series]:\n    \"\"\"\n    Replace empty strings with 0 without FutureWarning\n    Uses mask() instead of replace() to avoid pandas downcasting warnings.\n    Args:\n        data: pandas Series or DataFrame\n    Returns:\n        Data with empty strings replaced by 0\n    \"\"\"\n    if isinstance(data, pd.DataFrame):",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "to_numeric_safe",
        "kind": 2,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "def to_numeric_safe(data: Union[pd.DataFrame, pd.Series]) -> Union[pd.DataFrame, pd.Series]:\n    \"\"\"\n    Convert to numeric safely without downcasting warnings\n    Args:\n        data: pandas Series or DataFrame\n    Returns:\n        Numeric data\n    \"\"\"\n    if isinstance(data, pd.DataFrame):\n        return data.apply(pd.to_numeric, errors='coerce').fillna(0)",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "ensure_directory",
        "kind": 2,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "def ensure_directory(directory: Union[str, Path]) -> Path:\n    \"\"\"\n    Ensure a directory exists, create if it doesn't\n    Args:\n        directory: Path to directory\n    Returns:\n        Path object to the directory\n    Raises:\n        OutputDirectoryError: If directory cannot be created\n    \"\"\"",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "ensure_trace_dir",
        "kind": 2,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "def ensure_trace_dir(output_dir: Union[str, Path]) -> Path:\n    \"\"\"\n    Ensure Trace directory exists for visualization data exports\n    Args:\n        output_dir: Base output directory\n    Returns:\n        Path to Trace directory\n    \"\"\"\n    trace_dir = Path(output_dir) / TRACE_DIR\n    return ensure_directory(trace_dir)",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "save_trace_data",
        "kind": 2,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "def save_trace_data(data: pd.DataFrame, output_dir: Union[str, Path], filename: str) -> Path:\n    \"\"\"\n    Save visualization source data to Trace folder\n    Args:\n        data: DataFrame to save\n        output_dir: Base output directory\n        filename: Name of the trace file (e.g., 'heatmap_data.csv')\n    Returns:\n        Path to saved file\n    Raises:",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "get_sample_columns",
        "kind": 2,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "def get_sample_columns(df: pd.DataFrame,\n                       exclude_metadata: bool = True) -> Tuple[List[str], List[str]]:\n    \"\"\"\n    Extract cancer and normal sample columns from DataFrame\n    Identifies columns that represent cancer samples (start with 'C' followed by digits)\n    and normal samples (start with 'N' followed by digits).\n    Args:\n        df: DataFrame with sample columns\n        exclude_metadata: If True, only return sample columns (no metadata)\n    Returns:",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "get_all_sample_columns",
        "kind": 2,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "def get_all_sample_columns(df: pd.DataFrame) -> List[str]:\n    \"\"\"\n    Get all sample columns (both cancer and normal)\n    Args:\n        df: DataFrame with sample columns\n    Returns:\n        List of all sample column names sorted (C samples first, then N samples)\n    \"\"\"\n    cancer_samples, normal_samples = get_sample_columns(df)\n    return cancer_samples + normal_samples",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "get_metadata_columns",
        "kind": 2,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "def get_metadata_columns(df: pd.DataFrame) -> List[str]:\n    \"\"\"\n    Get metadata columns from DataFrame\n    Args:\n        df: DataFrame\n    Returns:\n        List of metadata column names that exist in the DataFrame\n    \"\"\"\n    return [col for col in df.columns if col in METADATA_COLUMNS]\n# ==============================================================================",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "extract_sample_id",
        "kind": 2,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "def extract_sample_id(filename: str) -> str:\n    \"\"\"\n    Extract sample ID from filename (e.g., C_01.csv -> C1)\n    Args:\n        filename: Name of the CSV file\n    Returns:\n        Sample ID (e.g., 'C1', 'N10')\n    \"\"\"\n    match = re.search(SAMPLE_ID_PATTERN, filename)\n    if match:",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "get_sample_group",
        "kind": 2,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "def get_sample_group(sample_name: str) -> str:\n    \"\"\"\n    Determine if sample is Cancer or Normal based on name\n    Args:\n        sample_name: Sample column name (e.g., 'C1', 'N10')\n    Returns:\n        'Cancer' or 'Normal'\n    \"\"\"\n    if sample_name.startswith(CANCER_PREFIX):\n        return GROUP_CANCER",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "is_cancer_sample",
        "kind": 2,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "def is_cancer_sample(sample_name: str) -> bool:\n    \"\"\"Check if sample is a cancer sample\"\"\"\n    return sample_name.startswith(CANCER_PREFIX)\ndef is_normal_sample(sample_name: str) -> bool:\n    \"\"\"Check if sample is a normal sample\"\"\"\n    return sample_name.startswith(NORMAL_PREFIX)\n# ==============================================================================\n# Data Transformation\n# ==============================================================================\ndef log_transform(data: Union[pd.DataFrame, pd.Series, np.ndarray],",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "is_normal_sample",
        "kind": 2,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "def is_normal_sample(sample_name: str) -> bool:\n    \"\"\"Check if sample is a normal sample\"\"\"\n    return sample_name.startswith(NORMAL_PREFIX)\n# ==============================================================================\n# Data Transformation\n# ==============================================================================\ndef log_transform(data: Union[pd.DataFrame, pd.Series, np.ndarray],\n                 pseudocount: float = LOG_TRANSFORM_PSEUDOCOUNT) -> Union[pd.DataFrame, pd.Series, np.ndarray]:\n    \"\"\"\n    Apply log2 transformation with pseudocount",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "log_transform",
        "kind": 2,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "def log_transform(data: Union[pd.DataFrame, pd.Series, np.ndarray],\n                 pseudocount: float = LOG_TRANSFORM_PSEUDOCOUNT) -> Union[pd.DataFrame, pd.Series, np.ndarray]:\n    \"\"\"\n    Apply log2 transformation with pseudocount\n    Args:\n        data: Data to transform\n        pseudocount: Value to add before log transform (default: 1.0)\n    Returns:\n        Log2-transformed data\n    \"\"\"",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "calculate_fold_change",
        "kind": 2,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "def calculate_fold_change(cancer_mean: float, normal_mean: float,\n                         log_scale: bool = False) -> float:\n    \"\"\"\n    Calculate fold change between cancer and normal\n    Args:\n        cancer_mean: Mean intensity in cancer samples\n        normal_mean: Mean intensity in normal samples\n        log_scale: If True, return log2 fold change\n    Returns:\n        Fold change value",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "calculate_statistics",
        "kind": 2,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "def calculate_statistics(values: Union[pd.Series, np.ndarray]) -> dict:\n    \"\"\"\n    Calculate basic statistics for a set of values\n    Args:\n        values: Array of values\n    Returns:\n        Dictionary with mean, median, std, min, max\n    \"\"\"\n    if isinstance(values, pd.Series):\n        values = values.values",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "validate_sample_counts",
        "kind": 2,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "def validate_sample_counts(df: pd.DataFrame,\n                          min_cancer: int = 1,\n                          min_normal: int = 1) -> Tuple[int, int]:\n    \"\"\"\n    Validate sample counts in DataFrame\n    Args:\n        df: DataFrame with sample columns\n        min_cancer: Minimum number of cancer samples required\n        min_normal: Minimum number of normal samples required\n    Returns:",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "validate_dataframe_not_empty",
        "kind": 2,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "def validate_dataframe_not_empty(df: pd.DataFrame, context: str = \"\") -> None:\n    \"\"\"\n    Validate that DataFrame is not empty\n    Args:\n        df: DataFrame to validate\n        context: Context message for error\n    Raises:\n        ValidationError: If DataFrame is empty\n    \"\"\"\n    if df is None or len(df) == 0:",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "format_percentage",
        "kind": 2,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "def format_percentage(value: float, decimals: int = 1) -> str:\n    \"\"\"Format value as percentage string\"\"\"\n    return f\"{value * 100:.{decimals}f}%\"\ndef format_scientific(value: float, decimals: int = 2) -> str:\n    \"\"\"Format value in scientific notation\"\"\"\n    return f\"{value:.{decimals}e}\"\ndef format_pvalue(pvalue: float) -> str:\n    \"\"\"\n    Format p-value with appropriate precision\n    Args:",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "format_scientific",
        "kind": 2,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "def format_scientific(value: float, decimals: int = 2) -> str:\n    \"\"\"Format value in scientific notation\"\"\"\n    return f\"{value:.{decimals}e}\"\ndef format_pvalue(pvalue: float) -> str:\n    \"\"\"\n    Format p-value with appropriate precision\n    Args:\n        pvalue: P-value to format\n    Returns:\n        Formatted string (e.g., \"0.001\" or \"< 0.001\")",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "format_pvalue",
        "kind": 2,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "def format_pvalue(pvalue: float) -> str:\n    \"\"\"\n    Format p-value with appropriate precision\n    Args:\n        pvalue: P-value to format\n    Returns:\n        Formatted string (e.g., \"0.001\" or \"< 0.001\")\n    \"\"\"\n    if pvalue < 0.001:\n        return \"< 0.001\"",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "get_cached_metadata_columns",
        "kind": 2,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "def get_cached_metadata_columns() -> Tuple[str, ...]:\n    \"\"\"\n    Get metadata columns (cached for performance)\n    Returns:\n        Tuple of metadata column names\n    \"\"\"\n    return tuple(METADATA_COLUMNS)",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "logger = logging.getLogger(__name__)\n# ==============================================================================\n# Data Type Conversion\n# ==============================================================================\ndef replace_empty_with_zero(data: Union[pd.DataFrame, pd.Series]) -> Union[pd.DataFrame, pd.Series]:\n    \"\"\"\n    Replace empty strings with 0 without FutureWarning\n    Uses mask() instead of replace() to avoid pandas downcasting warnings.\n    Args:\n        data: pandas Series or DataFrame",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "GlycanVisualizer",
        "kind": 6,
        "importPath": "src.visualizer",
        "description": "src.visualizer",
        "peekOfCode": "class GlycanVisualizer(\n    PCAPlotMixin,\n    BoxplotMixin,\n    HeatmapMixin,\n    HistogramMixin,\n    VIPScorePlotMixin,\n    VIPScorePlotRMixin,\n    DistributionPlotMixin,\n    VolcanoPlotMixin,\n    SiteSpecificHeatmapMixin,",
        "detail": "src.visualizer",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.visualizer",
        "description": "src.visualizer",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass GlycanVisualizer(\n    PCAPlotMixin,\n    BoxplotMixin,\n    HeatmapMixin,\n    HistogramMixin,\n    VIPScorePlotMixin,\n    VIPScorePlotRMixin,\n    DistributionPlotMixin,\n    VolcanoPlotMixin,",
        "detail": "src.visualizer",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def main():\n    \"\"\"Main pipeline execution\"\"\"\n    logger.info(\"=\"*80)\n    logger.info(\"pGlyco Auto Combine - Glycoproteomics Data Analysis Pipeline\")\n    logger.info(\"=\"*80)\n    # Load and validate configuration\n    logger.info(\"\\n[1/6] Loading and validating configuration...\")\n    try:\n        config = load_and_validate_config('config.yaml')\n        logger.info(\"Configuration validated successfully\")",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "logger = get_logger(__name__)\ndef main():\n    \"\"\"Main pipeline execution\"\"\"\n    logger.info(\"=\"*80)\n    logger.info(\"pGlyco Auto Combine - Glycoproteomics Data Analysis Pipeline\")\n    logger.info(\"=\"*80)\n    # Load and validate configuration\n    logger.info(\"\\n[1/6] Loading and validating configuration...\")\n    try:\n        config = load_and_validate_config('config.yaml')",
        "detail": "main",
        "documentation": {}
    }
]